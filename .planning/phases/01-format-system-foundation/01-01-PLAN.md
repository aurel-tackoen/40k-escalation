---
phase: 01-format-system-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/data/format-registry.ts
  - db/schema.ts
autonomous: true

must_haves:
  truths:
    - "Format registry defines all 7 formats across 4 game systems with correct scoring/feature configs"
    - "Leagues table has a nullable format varchar column in the database"
    - "Helper functions can look up formats by game system shortName or format key"
  artifacts:
    - path: "app/data/format-registry.ts"
      provides: "Format configuration registry with FormatConfig interface, FORMAT_REGISTRY map, and helper functions"
      exports: ["FormatConfig", "FORMAT_REGISTRY", "getFormatsForGameSystem", "getFormatConfig", "getFormatDisplayName"]
    - path: "db/schema.ts"
      provides: "Updated leagues table with format column"
      contains: "format: varchar"
  key_links:
    - from: "app/data/format-registry.ts"
      to: "app/data/game-systems.js"
      via: "gameSystem field matches game-systems.js shortName values"
      pattern: "gameSystem: '(tow|40k|aos|hh)'"
---

<objective>
Create the format registry data file and add the format column to the database schema.

Purpose: This is the foundation that all other Phase 1 work depends on. The format registry defines what formats exist, what scoring they use, and what features they enable. The DB schema change allows leagues to store their selected format.

Output: `app/data/format-registry.ts` with all 7 format configs, updated `db/schema.ts` with format column, and a generated Drizzle migration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-format-system-foundation/01-RESEARCH.md

@db/schema.ts
@app/data/game-systems.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create format registry data file</name>
  <files>app/data/format-registry.ts</files>
  <action>
Create `app/data/format-registry.ts` as a TypeScript file (matching the .ts convention appropriate for typed data, unlike the existing .js data files which are untyped).

Define the `FormatConfig` interface with these fields:
- `key: string` — unique identifier (e.g., 'ow-ptg', '40k-matched')
- `name: string` — display name (e.g., 'Path to Glory', 'Matched Play', 'Crusade')
- `description: string` — short description for format selection UI
- `gameSystem: string` — matches shortName from game-systems.js ('tow', '40k', 'aos', 'hh')
- `category: 'campaign' | 'matched'` — for routing to progression vs simple behavior
- `scoring: { type: string, label: string, defaultRanking: string }` — scoring configuration
- `features: { progression: boolean, paintingBonus: boolean, matchForm: string, standingsType: string }` — feature flags

Define `FORMAT_REGISTRY: Record<string, FormatConfig>` with all 7 formats:

1. `ow-ptg`: Old World Path to Glory — campaign, CP scoring, progression: true, paintingBonus: true
2. `ow-matched`: Old World Matched Play — matched, TP scoring from VP differential
3. `40k-crusade`: 40k Crusade — campaign, W/L/D scoring, progression: true
4. `40k-matched`: 40k Matched Play — matched, VP scoring
5. `aos-ptg`: AoS Path to Glory — campaign, Glory Points scoring, progression: true
6. `aos-matched`: AoS Matched Play — matched, Match Points (3/1/0 system)
7. `hh-matched`: HH Matched Play — matched, Match Points (2/1/0 system)

Use the exact format configs from the RESEARCH.md (Pattern 1: Static Format Registry).

Export 3 helper functions:
- `getFormatsForGameSystem(shortName: string): FormatConfig[]` — filter by gameSystem
- `getFormatConfig(formatKey: string): FormatConfig | null` — single lookup
- `getFormatDisplayName(formatKey: string): string` — for badge text

Verify the gameSystem values match game-systems.js shortNames: 'tow' (not 'ow'), '40k', 'aos', 'hh'. Note: MESBG is not included in v0.2 format system — it has no formats defined.
  </action>
  <verify>
Run `npx tsx -e "const { FORMAT_REGISTRY, getFormatsForGameSystem } = require('./app/data/format-registry'); console.log(Object.keys(FORMAT_REGISTRY).length); console.log(getFormatsForGameSystem('tow').length); console.log(getFormatsForGameSystem('40k').length); console.log(getFormatsForGameSystem('hh').length)"` and confirm output is 7, 2, 2, 1.

If tsx import fails due to ESM, try: `npx tsx -e "import { FORMAT_REGISTRY, getFormatsForGameSystem } from './app/data/format-registry'; console.log(Object.keys(FORMAT_REGISTRY).length, getFormatsForGameSystem('tow').length, getFormatsForGameSystem('40k').length, getFormatsForGameSystem('hh').length)"`.
  </verify>
  <done>format-registry.ts exports FormatConfig interface, FORMAT_REGISTRY with 7 entries, and 3 helper functions. All gameSystem values match game-systems.js shortNames.</done>
</task>

<task type="auto">
  <name>Task 2: Add format column to leagues table and generate migration</name>
  <files>db/schema.ts</files>
  <action>
In `db/schema.ts`, add a `format` column to the `leagues` table definition, placed after the `gameSystemId` column:

```typescript
format: varchar('format', { length: 50 }),  // Format key from format-registry: 'ow-ptg', '40k-matched', etc.
```

The column is intentionally nullable — existing leagues will have null until the migration script (Plan 03) sets their format. New leagues will be required to have a format via application-level validation (Plan 02), not a DB constraint.

After editing schema.ts, generate the Drizzle migration:
```bash
npm run db:generate
```

This should produce a new migration file in the `migrations/` directory with an ALTER TABLE ADD COLUMN statement.

Do NOT run `npm run db:migrate` — the migration will be applied as part of deployment. Just generate the file.

Verify the generated migration SQL contains: `ALTER TABLE "leagues" ADD COLUMN "format" varchar(50);`
  </action>
  <verify>
1. Confirm `db/schema.ts` has the format column in the leagues table definition.
2. Confirm a new migration file exists in `migrations/` containing the ALTER TABLE statement.
3. Run `npx tsc --noEmit db/schema.ts` or check that the project builds: `npm run build` (if fast) or at minimum `npx nuxi typecheck` to verify no type errors.
  </verify>
  <done>Leagues table in schema.ts has nullable format varchar(50) column. Migration file generated with correct ALTER TABLE SQL. No type errors.</done>
</task>

</tasks>

<verification>
1. `app/data/format-registry.ts` exists with 7 format entries and 3 exported helpers
2. `db/schema.ts` leagues table has `format` column
3. New migration file exists in `migrations/` directory
4. No TypeScript compilation errors
</verification>

<success_criteria>
- FORMAT_REGISTRY has exactly 7 entries covering: ow-ptg, ow-matched, 40k-crusade, 40k-matched, aos-ptg, aos-matched, hh-matched
- Each format has correct gameSystem mapping (tow, 40k, aos, hh)
- getFormatsForGameSystem returns correct counts: tow=2, 40k=2, aos=2, hh=1
- Leagues table schema includes nullable format varchar column
- Drizzle migration generated successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-format-system-foundation/01-01-SUMMARY.md`
</output>
