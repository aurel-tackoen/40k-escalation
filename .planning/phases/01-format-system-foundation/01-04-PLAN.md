---
phase: 01-format-system-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - app/components/LeagueCard.vue
  - app/components/views/DashboardView.vue
  - app/components/views/LeagueSetupView.vue
  - server/api/leagues/[id].patch.ts
  - server/api/leagues/my.get.ts
autonomous: false

must_haves:
  truths:
    - "Format badge is visible on league cards in the browse/list view"
    - "Format badge is visible on the league header inside the dashboard"
    - "Badge shows full format name: 'Path to Glory', 'Matched Play', or 'Crusade'"
    - "Format is shown as read-only with lock icon in league settings when matches exist"
    - "Format can be changed in league settings if no matches have been recorded yet"
    - "Server rejects format changes via PATCH when matches exist"
  artifacts:
    - path: "app/components/LeagueCard.vue"
      provides: "Format badge on league cards"
      contains: "formatName"
    - path: "app/components/views/DashboardView.vue"
      provides: "Format badge near league name in dashboard header"
      contains: "formatName"
    - path: "app/components/views/LeagueSetupView.vue"
      provides: "Format display with immutability logic (editable vs locked)"
      contains: "hasMatches"
    - path: "server/api/leagues/[id].patch.ts"
      provides: "Server-side format immutability enforcement"
      contains: "Format cannot be changed"
    - path: "server/api/leagues/my.get.ts"
      provides: "Format field included in my leagues response"
      contains: "format"
  key_links:
    - from: "app/components/LeagueCard.vue"
      to: "app/data/format-registry.ts"
      via: "import getFormatDisplayName for badge text"
      pattern: "getFormatDisplayName"
    - from: "app/components/views/LeagueSetupView.vue"
      to: "server/api/leagues/[id].patch.ts"
      via: "PATCH request to update format (when allowed)"
      pattern: "format"
    - from: "server/api/leagues/[id].patch.ts"
      to: "db/schema.ts"
      via: "counts matches to enforce immutability"
      pattern: "matches.*count"
---

<objective>
Add format badges to league cards and dashboard, implement format immutability in settings, and ensure format data flows through all league endpoints.

Purpose: Users see which format a league uses (LOCKED: "Subtle badge/tag near the league name"), and the format is protected from changes after matches are recorded (LOCKED: "Once a match is recorded, format locks permanently").

Output: Format badges on LeagueCard and DashboardView, editable/locked format in LeagueSetupView, server-side immutability enforcement, and format included in all league API responses.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-format-system-foundation/01-RESEARCH.md
@.planning/phases/01-format-system-foundation/01-02-SUMMARY.md

@app/components/LeagueCard.vue
@app/components/views/DashboardView.vue
@app/components/views/LeagueSetupView.vue
@server/api/leagues/[id].patch.ts
@server/api/leagues/my.get.ts
@app/data/format-registry.ts
@app/stores/leagues.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add format badge to LeagueCard and DashboardView</name>
  <files>app/components/LeagueCard.vue, app/components/views/DashboardView.vue</files>
  <action>
**LeagueCard.vue:**

1. Import `getFormatDisplayName` from `~/data/format-registry`
2. Add a computed property for the format display name:
   ```javascript
   const formatName = computed(() => {
     return props.league?.format ? getFormatDisplayName(props.league.format) : null
   })
   ```
3. Add a subtle badge near the league name in the card template. Use the styling from RESEARCH.md:
   ```html
   <span
     v-if="formatName"
     class="text-xs font-medium px-2 py-0.5 rounded-full bg-gray-700 text-gray-300 border border-gray-600"
   >
     {{ formatName }}
   </span>
   ```
   Place it after the league name, on the same line or directly below depending on the existing layout. The badge should be SUBTLE — it's a secondary piece of info, not the main focus (LOCKED decision).
4. All leagues use the same card style — no visual distinction between campaign and classic formats beyond badge text (LOCKED decision).

**DashboardView.vue:**

1. Import `getFormatDisplayName` from `~/data/format-registry`
2. Find the league header section (where the league name is displayed near the top of the dashboard)
3. Add a computed for format name using the current league's format:
   ```javascript
   const formatName = computed(() => {
     const league = leaguesStore.currentLeague  // or however the current league is accessed
     return league?.format ? getFormatDisplayName(league.format) : null
   })
   ```
4. Add the same subtle badge style near the league name in the header
5. Use `v-if="formatName"` so leagues without format (pre-migration) don't show a broken badge

**Important:** The badge shows FULL format names only: "Path to Glory", "Matched Play", "Crusade" — NOT abbreviations like "PtG" or keys like "ow-ptg" (LOCKED decision).
  </action>
  <verify>
Run `npm run build` to verify no compilation errors. Visually inspect (or check template) that the badge is placed near the league name in both components.
  </verify>
  <done>Format badge appears on LeagueCard and DashboardView header showing full format name. Badge is subtle (small, muted colors). Gracefully hidden when league has no format.</done>
</task>

<task type="auto">
  <name>Task 2: Implement format immutability in settings and API</name>
  <files>app/components/views/LeagueSetupView.vue, server/api/leagues/[id].patch.ts, server/api/leagues/my.get.ts</files>
  <action>
**server/api/leagues/my.get.ts:**

This endpoint manually constructs its response (per RESEARCH.md pitfall #1). Add `format` to the response object so it's available in the league list. Find where the league data is mapped/constructed and add `format: league.format` to the output.

Also check `server/api/leagues/public.get.ts` and `server/api/leagues/info-by-token/[token].get.ts` — if they manually construct responses, add format there too. If they use `select().from(leagues)`, format is auto-included.

**server/api/leagues/[id].patch.ts:**

1. Import `getFormatConfig` from the format registry (use appropriate path for server context)
2. Add format immutability check: if `body.format` is being changed, count matches for this league:
   ```typescript
   if (body.format !== undefined) {
     // Validate format key
     if (!getFormatConfig(body.format)) {
       throw createError({
         statusCode: 400,
         statusMessage: 'Invalid league format'
       })
     }
     // Check if matches exist — format locks after first match
     const matchCount = await db
       .select({ count: sql`count(*)::int` })
       .from(matches)
       .where(eq(matches.leagueId, leagueId))
     if (matchCount[0].count > 0) {
       throw createError({
         statusCode: 400,
         statusMessage: 'Format cannot be changed after matches have been recorded'
       })
     }
   }
   ```
   Import `sql` from `drizzle-orm` and `matches` from the schema if not already imported.
3. Add `format` to the update SET clause (alongside other fields being updated)

**app/stores/leagues.js:**

1. In the `updateLeague` action, ensure format is passed through to the PATCH endpoint
2. After a successful update, also update the format in the `myLeagues` entry (per RESEARCH.md pitfall #5 — cache invalidation). Look for where the store updates `this.myLeagues` after a league settings change (around line 547 per research) and add format.

**app/components/views/LeagueSetupView.vue:**

1. Import `getFormatsForGameSystem`, `getFormatDisplayName` from `~/data/format-registry`
2. Import `Lock` icon from `lucide-vue-next`
3. Determine if matches exist for the current league. The component likely has access to matches via the store. Add a computed:
   ```javascript
   const hasMatches = computed(() => {
     return leaguesStore.matches && leaguesStore.matches.length > 0
   })
   ```
   (Adjust based on how matches are accessed in this component)
4. Add available formats computed (filtered by current game system):
   ```javascript
   const availableFormats = computed(() => {
     const gameSystem = leaguesStore.currentGameSystem
     if (!gameSystem) return []
     return getFormatsForGameSystem(gameSystem.shortName)
   })
   ```
5. Add format display name computed:
   ```javascript
   const currentFormatName = computed(() => {
     return editableLeague.format ? getFormatDisplayName(editableLeague.format) : 'Not set'
   })
   ```
6. In the template, add a format section in the league settings form (in the settings grid, likely spanning 2 columns):
   - **If no matches (editable):** Show a `<select>` dropdown with available formats for the current game system. Bind to `editableLeague.format`. Show label "League Format".
   - **If matches exist (locked):** Show the format name as read-only text with a Lock icon and explanation message "Format locked -- matches have been recorded". Use the styling from RESEARCH.md.
   - Add a watcher: if game system changes in settings AND no matches, clear the format (same pattern as create form)
  </action>
  <verify>
1. Run `npm run build` to verify no compilation errors.
2. Run `npm run lint` to check for linting issues.
3. Verify the PATCH endpoint rejects format changes when matches exist by reviewing the code logic.
  </verify>
  <done>Format is editable in settings before first match, locked with explanation after. Server enforces immutability. Format included in all league API responses (my.get.ts patched). Store cache updated after format change.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify format system end-to-end</name>
  <what-built>
Complete format system: registry, league creation with format selection, format badges on cards and dashboard, format immutability in settings, migration script for existing leagues.
  </what-built>
  <how-to-verify>
1. Start the dev server: `npm run dev`
2. Navigate to league creation page
3. Select a game system (e.g., "The Old World") and verify format options appear (should show "Path to Glory" and "Matched Play")
4. Select HH — verify single format "Matched Play" still shows (not skipped)
5. Change game system — verify format selection resets
6. Try submitting without format — verify validation error
7. Create a league with a format — verify it saves
8. Check league card — verify format badge shows full name (e.g., "Path to Glory")
9. Check dashboard header — verify format badge shows
10. Go to league settings — verify format is editable (no matches yet)
11. Change format to different one, save — verify it updates
12. Record a match in the league
13. Go back to settings — verify format is now locked with lock icon and explanation
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Format badge visible on LeagueCard component
2. Format badge visible on DashboardView header
3. LeagueSetupView shows editable format (no matches) or locked format (has matches)
4. PATCH endpoint rejects format changes when matches exist (400 error)
5. my.get.ts includes format in response
6. Store updates format in myLeagues cache after settings change
</verification>

<success_criteria>
- Format badge shows "Path to Glory", "Matched Play", or "Crusade" (full names, not abbreviations)
- Badge styling is subtle: small text, muted colors, not the main focus
- Settings show Lock icon + "Format locked -- matches have been recorded" when locked
- Settings allow format change when no matches exist
- Server returns 400 when attempting to change format after matches recorded
- All league endpoints include format in their response
</success_criteria>

<output>
After completion, create `.planning/phases/01-format-system-foundation/01-04-SUMMARY.md`
</output>
